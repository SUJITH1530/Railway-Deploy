<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Live Traffic Dashboard</title>
    <link rel="stylesheet" href="/static/style.css">
</head>
<body>

<header>
    <h1>AI-Based Real-Time Traffic Density Estimation and Control System for Sustainable Urban Transportation
 </h1>
    <nav>
        <a href="/">Home</a>
        <a href="/dashboard">Dashboard</a>
        <a href="https://web-production-d267a.up.railway.app/" target="_blank" rel="noopener">Main Site</a>
    </nav>
    <p style="margin:8px 0 0 0; opacity:0.8;">Upload images to detect vehicles and dynamically manage traffic signals based on density.</p>
</header>

<div class="container">

    <div class="card" style="max-width:820px; width:90%; text-align:left;">
        <h3>Upload lane images</h3>
        <div id="drop" class="upload-box">
            <span>Drag and drop files here</span>
            <button id="browseBtn" type="button">Browse files</button>
            <input id="fileInput" type="file" accept="image/*" style="display:none">
        </div>
        <div style="margin-top:10px">
            <button id="startBtn">Use Camera</button>
            <button id="captureBtn">Capture & Upload</button>
            <button id="stopCamBtn" type="button" style="margin-left:8px; background:#475569;">Stop Camera</button>
            <video id="video" width="480" height="320" autoplay style="display:none; border:1px solid #333; margin-top:8px;"></video>
            <div id="camError" style="display:none; margin-top:8px; color:#fca5a5;"></div>
            <div style="margin-top:8px">
                <label for="laneSelect">Assign detection to:</label>
                <select id="laneSelect">
                    <option value="lane1">Lane 1</option>
                    <option value="lane2">Lane 2</option>
                    <option value="lane3">Lane 3</option>
                    <option value="lane4">Lane 4</option>
                </select>
            </div>
            <div style="margin-top:8px">
                <button id="multiBtn" type="button">Upload 4 Lanes</button>
                <input id="multiInput" type="file" multiple accept="image/*" style="display:none">
                <small style="margin-left:8px; opacity:0.8;">Select up to 4 images (order maps to Lane1..4)</small>
            </div>
        </div>
    </div>

    <div class="card" style="max-width:900px; width:95%; text-align:left;">
        <h3>Vehicle Detection Results</h3>
        <img id="processed" src="" alt="Processed" style="max-width:100%; border-radius:8px; display:none;"/>
        <p id="laneLabel" style="margin-top:8px; opacity:0.8; display:none;">Lane 1</p>
        <ul id="classList" style="display:none"></ul>
        <div id="recommend" class="recommend" style="display:none"></div>
        <div style="margin-top:10px">
            <b>Lane counts</b> — 
            L1: <span id="c_lane1">0</span> | 
            L2: <span id="c_lane2">0</span> | 
            L3: <span id="c_lane3">0</span> | 
            L4: <span id="c_lane4">0</span>
        </div>
        <div style="margin-top:10px">
            <b>Suggested order</b>: <span id="orderBadges"></span>
            <button id="useOrderBtn" style="margin-left:8px;">Use order</button>
            <button id="clearOrderBtn" style="margin-left:6px; background:#475569;">Clear</button>
        </div>
    </div>

    <div class="card" style="max-width:900px; width:95%; text-align:left;">
        <h3>Signal Simulation</h3>
        <div class="lanes">
            <div class="lane" id="lane1">
                <div class="light red"></div>
                <div class="light amber"></div>
                <div class="light green"></div>
                <div class="lane-title">Lane 1</div>
            </div>
            <div class="lane" id="lane2">
                <div class="light red"></div>
                <div class="light amber"></div>
                <div class="light green"></div>
                <div class="lane-title">Lane 2</div>
            </div>
            <div class="lane" id="lane3">
                <div class="light red"></div>
                <div class="light amber"></div>
                <div class="light green"></div>
                <div class="lane-title">Lane 3</div>
            </div>
            <div class="lane" id="lane4">
                <div class="light red"></div>
                <div class="light amber"></div>
                <div class="light green"></div>
                <div class="lane-title">Lane 4</div>
            </div>
        </div>
        <div style="margin-top:8px; opacity:0.8;">Opening <b id="openLane">Lane 1</b> for <span id="openSeconds">0</span> seconds ...</div>
        <div style="margin-top:10px">
            <button id="startCycleBtn">Start Signal Cycle</button>
            <button id="stopCycleBtn" style="background:#ef4444; margin-left:8px;">Stop</button>
            <small style="margin-left:10px; opacity:0.8;">Cycle order is based on current lane counts (highest first).</small>
        </div>
    </div>

    <div class="card" style="max-width:900px; width:95%; text-align:left;">
        <h3>Lane Countdown</h3>
        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:10px;">
            <div>Lane 1: <span id="t_lane1">-</span></div>
            <div>Lane 2: <span id="t_lane2">-</span></div>
            <div>Lane 3: <span id="t_lane3">-</span></div>
            <div>Lane 4: <span id="t_lane4">-</span></div>
        </div>
    </div>

    <div class="card" style="max-width:900px; width:95%; text-align:left;">
        <h3>Lane Preview</h3>
        <div class="preview-grid">
            <div class="preview-item">
                <div style="margin-bottom:6px; opacity:0.8;">Lane 1</div>
                <img id="img_lane1" src="" alt="Lane 1" />
                <div class="density-badge" id="d_lane1">0% density</div>
                <button class="lane-action" data-lane="lane1">Delete/Reset</button>
            </div>
            <div class="preview-item">
                <div style="margin-bottom:6px; opacity:0.8;">Lane 2</div>
                <img id="img_lane2" src="" alt="Lane 2" />
                <div class="density-badge" id="d_lane2">0% density</div>
                <button class="lane-action" data-lane="lane2">Delete/Reset</button>
            </div>
            <div class="preview-item">
                <div style="margin-bottom:6px; opacity:0.8;">Lane 3</div>
                <img id="img_lane3" src="" alt="Lane 3" />
                <div class="density-badge" id="d_lane3">0% density</div>
                <button class="lane-action" data-lane="lane3">Delete/Reset</button>
            </div>
            <div class="preview-item">
                <div style="margin-bottom:6px; opacity:0.8;">Lane 4</div>
                <img id="img_lane4" src="" alt="Lane 4" />
                <div class="density-badge" id="d_lane4">0% density</div>
                <button class="lane-action" data-lane="lane4">Delete/Reset</button>
            </div>
        </div>
    </div>

</div>

<script>
// live data updater: pulls lane counts from server
function fetchData() {
    fetch('/data')
        .then(response => response.json())
        .then(data => {
            if (data && data.lanes) {
                applyServerLanes(data.lanes);
            }
        })
        .catch(err => console.error(err));
}
fetchData();
setInterval(fetchData, 2000);

// camera + upload handling
const video = document.getElementById('video');
const startBtn = document.getElementById('startBtn');
const captureBtn = document.getElementById('captureBtn');
const stopCamBtn = document.getElementById('stopCamBtn');
const fileInput = document.getElementById('fileInput');
const processedImg = document.getElementById('processed');
const classList = document.getElementById('classList');
const laneLabel = document.getElementById('laneLabel');
const recommend = document.getElementById('recommend');
const drop = document.getElementById('drop');
const browseBtn = document.getElementById('browseBtn');
const openSeconds = document.getElementById('openSeconds');
const openLane = document.getElementById('openLane');
const laneSelect = document.getElementById('laneSelect');
const multiBtn = document.getElementById('multiBtn');
const multiInput = document.getElementById('multiInput');
const useOrderBtn = document.getElementById('useOrderBtn');
const clearOrderBtn = document.getElementById('clearOrderBtn');
const orderBadges = document.getElementById('orderBadges');
const previewImgs = {
    lane1: document.getElementById('img_lane1'),
    lane2: document.getElementById('img_lane2'),
    lane3: document.getElementById('img_lane3'),
    lane4: document.getElementById('img_lane4'),
};
const densityEls = {
    lane1: document.getElementById('d_lane1'),
    lane2: document.getElementById('d_lane2'),
    lane3: document.getElementById('d_lane3'),
    lane4: document.getElementById('d_lane4'),
};
const deleteButtons = Array.from(document.querySelectorAll('.lane-action'));
const countEls = {
    lane1: document.getElementById('c_lane1'),
    lane2: document.getElementById('c_lane2'),
    lane3: document.getElementById('c_lane3'),
    lane4: document.getElementById('c_lane4'),
};
let laneCounts = { lane1: 0, lane2: 0, lane3: 0, lane4: 0 };
let laneGreen = { lane1: 10, lane2: 10, lane3: 10, lane4: 10 };
let cycling = false;
let stream = null;
let fixedOrder = null; // set by "Use order" button
const laneTimerEls = {
    lane1: document.getElementById('t_lane1'),
    lane2: document.getElementById('t_lane2'),
    lane3: document.getElementById('t_lane3'),
    lane4: document.getElementById('t_lane4'),
};

startBtn.addEventListener('click', async () => {
    if (stream) return;
    const constraints = { video: { facingMode: 'environment' }, audio: false };
    const errorBox = document.getElementById('camError');
    errorBox.style.display = 'none';
    errorBox.textContent = '';
    try {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('getUserMedia not supported in this browser');
        }
        // stop any lingering tracks (defensive) before starting
        stopCamera();
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        video.style.display = 'block';
    } catch (err) {
        console.error(err);
        let msg = 'Camera access denied or not available.';
        if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            msg = 'Camera permission denied. Click the lock icon in the address bar → allow Camera. Then reload the page.';
        } else if (err.name === 'NotFoundError' || err.name === 'OverconstrainedError') {
            msg = 'No camera found. Connect a webcam or try a different device.';
        } else if (err.name === 'NotReadableError') {
            msg = 'Camera is in use by another app. Close other apps (Teams/Zoom/Camera) and try again.';
        } else if (location.hostname !== 'localhost' && location.hostname !== '127.0.0.1' && location.protocol !== 'https:') {
            msg = 'Browsers require HTTPS for camera on non-localhost. Use http://localhost:5000 or enable HTTPS.';
        }
        errorBox.textContent = msg;
        errorBox.style.display = 'block';
    }
});

browseBtn.addEventListener('click', () => fileInput.click());
multiBtn.addEventListener('click', () => multiInput.click());
drop.addEventListener('dragover', (e) => { e.preventDefault(); drop.classList.add('hover'); });
drop.addEventListener('dragleave', () => drop.classList.remove('hover'));
drop.addEventListener('drop', (e) => {
    e.preventDefault();
    drop.classList.remove('hover');
    if (e.dataTransfer.files.length) {
        uploadFile(e.dataTransfer.files[0]);
    }
});

captureBtn.addEventListener('click', async () => {
    // capture frame from video and send as base64
    if (!stream) {
        alert('Start camera first or upload a file');
        return;
    }
    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth || 640;
    canvas.height = video.videoHeight || 480;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    const dataUrl = canvas.toDataURL('image/jpeg');
    uploadBase64(dataUrl);
});

stopCamBtn.addEventListener('click', () => {
    stopCamera();
});

fileInput.addEventListener('change', async (e) => {
    const f = e.target.files[0];
    if (!f) return;
    uploadFile(f);
});

async function uploadFile(f) {
    const form = new FormData();
    form.append('image', f);
    form.append('lane', laneSelect.value);
    const res = await fetch('/upload', { method: 'POST', body: form });
    const data = await res.json();
    showResults(data);
}

async function uploadBase64(dataUrl) {
    const res = await fetch('/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image: dataUrl, lane: laneSelect.value })
    });
    const data = await res.json();
    showResults(data);
}

multiInput.addEventListener('change', async (e) => {
    const files = Array.from(e.target.files || []);
    if (files.length === 0) return;
    const form = new FormData();
    ['lane1','lane2','lane3','lane4'].forEach((lane, idx) => {
        if (files[idx]) form.append(lane, files[idx]);
    });
    const res = await fetch('/upload-multi', { method: 'POST', body: form });
    const data = await res.json();
    if (data && data.lanes) applyServerLanes(data.lanes);
    const first = Object.values(data.results || {})[0];
    if (first && first.processed_image) {
        processedImg.style.display = 'block';
        processedImg.src = first.processed_image;
    }
});

function showResults(data) {
    if (!data || !data.processed_image) return;
    processedImg.style.display = 'block';
    processedImg.src = data.processed_image;
    laneLabel.style.display = 'block';
    const lane = laneSelect.value;
    laneCounts[lane] = data.vehicles || 0;
    laneGreen[lane] = data.green_time || computeGreenTime(laneCounts[lane]);
    laneLabel.textContent = `${lane.replace('lane','Lane ')} — Vehicles Detected: ${laneCounts[lane]}`;
    classList.style.display = 'block';
    classList.innerHTML = '';
    if (data.classes) {
        Object.keys(data.classes).forEach(k => {
            const li = document.createElement('li');
            li.textContent = `${k}: ${data.classes[k]}`;
            classList.appendChild(li);
        });
    }
    recommend.style.display = 'block';
    recommend.textContent = `Recommended signal switch time for ${lane.replace('lane','Lane ')}: ${data.green_time} seconds`;
    Object.keys(countEls).forEach(k => { countEls[k].textContent = laneCounts[k]; });
    updateDensityBadges();
    if (data.lanes) applyServerLanes(data.lanes);
    // update signal simulation
    setLights(lane, 'green');
}

function setLights(laneId, color) {
    const lane = document.getElementById(laneId);
    if (!lane) return;
    lane.querySelectorAll('.light').forEach(el => el.classList.remove('on'));
    lane.querySelector(`.light.${color}`).classList.add('on');
}

function applyServerLanes(lanes) {
    laneCounts = {
        lane1: (lanes.lane1 && lanes.lane1.count) ?? laneCounts.lane1,
        lane2: (lanes.lane2 && lanes.lane2.count) ?? laneCounts.lane2,
        lane3: (lanes.lane3 && lanes.lane3.count) ?? laneCounts.lane3,
        lane4: (lanes.lane4 && lanes.lane4.count) ?? laneCounts.lane4,
    };
    laneGreen = {
        lane1: (lanes.lane1 && lanes.lane1.green_time) ?? laneGreen.lane1,
        lane2: (lanes.lane2 && lanes.lane2.green_time) ?? laneGreen.lane2,
        lane3: (lanes.lane3 && lanes.lane3.green_time) ?? laneGreen.lane3,
        lane4: (lanes.lane4 && lanes.lane4.green_time) ?? laneGreen.lane4,
    };
    Object.keys(countEls).forEach(k => { countEls[k].textContent = laneCounts[k]; });
    // update previews
    ['lane1','lane2','lane3','lane4'].forEach(l => {
        const img = lanes[l] && lanes[l].image;
        if (img) previewImgs[l].src = img;
    });
    updateDensityBadges();
    const order = Object.entries(laneCounts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0])).map(e=>e[0]);
    showOrder(order);
}

function showOrder(order){
    orderBadges.innerHTML = '';
    order.forEach((lane, idx) => {
        const span = document.createElement('span');
        span.className = 'order-badge';
        span.textContent = `${idx+1}. ${lane.replace('lane','Lane ')}`;
        orderBadges.appendChild(span);
    });
}

useOrderBtn.addEventListener('click', () => {
    const order = Object.entries(laneCounts).sort((a,b)=>b[1]-a[1]||a[0].localeCompare(b[0])).map(e=>e[0]);
    fixedOrder = order;
    showOrder(order);
});

clearOrderBtn.addEventListener('click', () => {
    fixedOrder = null;
    orderBadges.innerHTML = '';
});

function computeGreenTime(count) {
    if (count <= 5) return 10;
    if (count <= 15) return 20;
    return 30;
}

function updateDensityBadges() {
    const maxCount = Math.max(...Object.values(laneCounts || {}), 0);
    const baseline = maxCount || 1;
    ['lane1','lane2','lane3','lane4'].forEach(l => {
        const pct = Math.round(((laneCounts[l] || 0) / baseline) * 100);
        const el = densityEls[l];
        if (el) el.textContent = `${pct}% density`;
    });
}

function resetLaneTimers() {
    Object.values(laneTimerEls).forEach(el => { if (el) el.textContent = '-'; });
}

async function clearLane(lane) {
    try {
        const res = await fetch('/clear-lane', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ lane })
        });
        const data = await res.json();
        if (data && data.lanes) {
            applyServerLanes(data.lanes);
        }
        // defensive UI reset
        laneCounts[lane] = 0;
        laneGreen[lane] = computeGreenTime(0);
        if (previewImgs[lane]) previewImgs[lane].src = '';
        updateDensityBadges();
    } catch (err) {
        console.error(err);
    }
}

document.getElementById('startCycleBtn').addEventListener('click', () => {
    cycling = true;
    runCycle();
});
document.getElementById('stopCycleBtn').addEventListener('click', () => {
    cycling = false;
    resetLaneTimers();
    openSeconds.textContent = '0';
});

async function runCycle() {
    while (cycling) {
        // pick order based on counts (highest first). If all zero, use numeric order

deleteButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        const lane = btn.getAttribute('data-lane');
        clearLane(lane);
    });
});
        let entries;
        if (Array.isArray(fixedOrder) && fixedOrder.length) {
            entries = fixedOrder.map(l => [l, laneCounts[l] ?? 0]);
        } else {
            entries = Object.entries(laneCounts);
            entries.sort((a,b) => b[1]-a[1] || a[0].localeCompare(b[0]));
            showOrder(entries.map(e=>e[0]));
        }
        const plan = entries.map(([lane,count]) => ({ lane, duration: computeGreenTime(count) }));
        for (let idx=0; idx<plan.length; idx++) {
            const { lane, duration } = plan[idx];
            if (!cycling) break;
            openLane.textContent = lane.replace('lane','Lane ');
            openSeconds.textContent = duration;
            // set all reds
            ['lane1','lane2','lane3','lane4'].forEach(l => setLights(l, 'red'));
            setLights(lane, 'green');
            resetLaneTimers();
            await countdown(plan, idx);
            // amber 2s
            setLights(lane, 'amber');
            await sleep(2000);
        }
    }
    // after stop, set all red
    ['lane1','lane2','lane3','lane4'].forEach(l => setLights(l, 'red'));
    resetLaneTimers();
}

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
async function countdown(plan, currentIdx){
    const current = plan[currentIdx];
    for (let s=current.duration; s>0 && cycling; s--) {
        openSeconds.textContent = s;
        updateLaneTimers(plan, currentIdx, s);
        await sleep(1000);
    }
    if (laneTimerEls[current.lane]) laneTimerEls[current.lane].textContent = '0s';
}

function updateLaneTimers(plan, currentIdx, secondsRemainingCurrent){
    plan.forEach((p, idx) => {
        const el = laneTimerEls[p.lane];
        if (!el) return;
        if (idx === currentIdx) {
            el.textContent = `${secondsRemainingCurrent}s`;
        } else if (idx > currentIdx) {
            let until = secondsRemainingCurrent;
            for (let i=currentIdx+1; i<=idx-1; i++) {
                until += plan[i].duration;
            }
            el.textContent = `${until}s`;
        } else {
            el.textContent = '-';
        }
    });
}

function stopCamera() {
    if (stream && stream.getTracks) {
        stream.getTracks().forEach(t => t.stop());
    }
    stream = null;
    if (video) {
        video.srcObject = null;
        video.style.display = 'none';
    }
}

// stop camera when tab hidden
document.addEventListener('visibilitychange', () => {
    if (document.hidden) stopCamera();
});
</script>

</body>
</html>
